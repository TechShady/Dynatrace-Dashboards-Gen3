{"version":13,"variables":[{"key":"OutageCost","type":"csv","input":"100,200,300,400,500,1000,2000,3000,4000,5000","multiple":false}],"tiles":{"33":{"type":"code","title":"Closed Problems","input":"import { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nasync function getProblemsList() {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n   //from: 'now-7d', problemSelector: 'managementZones(\"EasyTrade\")'\n    from: startTime,to: endTime, problemSelector: \"status(Closed), text(\\\"outage\\\")\"\n    //from: 'now-7d', problemSelector: \"status(Open)\"\n  });\n  const result = await response;\n // console.log(result.problems);\n  return result.problems;\n}\n\nfunction expandArray(array) {\n  if (array.length == 1) {\n    return array[0].name;\n  } else if (array.length > 1) {\n    var retVal = \"\"\n    for (let i=0;i<array.length;i++) {\n      if (i!=0) {\n        retVal = retVal + \", \" + array[i].name;\n      } else {\n        retVal = array[i].name;\n      }\n    }\n    return retVal;\n  }\n  return \"\"; \n}\n\nexport default async function () {\n  const response = await getProblemsList();\n  //console.log(response);\n  const problems=response;\n  const types = [{\n      mappings: {\n        startTime: {type: 'timestamp'},\n        status: {type: 'string'},\n        displayId: {type: 'string'},\n        title: {type: 'string'},\n        impactLevel: {type: 'string'},\n        severityLevel: {type: 'string'},\n        affectedEntities: {type: 'string'},\n        duration: {type: 'double'},\n        impactedEntities: {type: 'string'},\n        rootCauseEntity: {type: 'string'},\n        \"event.id\": {type: 'string'},\n        endTime: {type: 'timestamp'}\n        },\n        indexRange: [\n        0,\n        problems.length\n      ]\n  }]\n  //console.log(types);\n  // Create a new empty data frame for the result\n  const dataFrame = {\n    records: [],\n    types: types\n  }\n  \n  for(let i=0; i<problems.length; i++) {\n      const problem = problems[i];\n      var duration = \"\";\n      if (problem.endTime == null || problem.endTime == \"\" || problem.endTime < 0) {\n        duration = Math.round(((Date.now() - problem.startTime)/1000)/60);\n      } else {\n        duration = Math.round(((problem.endTime-problem.startTime)/1000)/60);\n      }\n      var pstatus = \"\";\n      if (problem.status == 'OPEN') {\n        pstatus = \"ðŸ”´ OPEN\";\n      } else {\n        pstatus = 'ðŸŸ¢ CLOSED';\n      }\n      var affectedEntities = expandArray(problem.affectedEntities);\n      var impactedEntities = expandArray(problem.impactedEntities);\n      var rootCause = \"\";\n      if (problem.rootCauseEntity == null) {\n        rootCause = \"\"\n      } else {\n        rootCause = problem.rootCauseEntity[\"name\"];\n      }\n       const record = {\n              startTime: problem.startTime,\n              status: pstatus,\n              displayId: problem.displayId,\n              title: problem.title,\n              impactLevel: problem.impactLevel,\n              severityLevel: problem.severityLevel,\n              affectedEntities: affectedEntities,\n              impactedEntities: impactedEntities,\n              rootCauseEntity: rootCause,\n              duration: duration,\n              \"event.id\": problem.problemId,\n              endTime: problem.endTime\n            }\n        dataFrame.records.push(record);\n    }\n  //console.log(dataFrame);\n  return dataFrame;\n}","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","categoricalBarChartSettings":{"categoryAxis":"status","categoryAxisLabel":"status","valueAxis":"duration","valueAxisLabel":"duration"},"fieldMapping":{"timestamp":"startTime","leftAxisValues":["duration"],"leftAxisDimensions":["status"]}},"singleValue":{"showLabel":true,"label":"","autoscale":true,"recordField":"startTime"},"table":{"enableLineWrap":true,"hiddenColumns":[["impactLevel"],["severityLevel"],["affectedEntities"],["rootCauseEntity"],["status"]],"lineWrapIds":[["affectedEntities"]]},"tableSettings":{"displayMode":"edit","lineWrapIds":[],"hiddenColumns":[["dataPond"],["rollupType"],["tenant"],["recordType"],["impactLevel"],["endTime"]],"firstVisibleRowIndex":0},"histogram":{"dataMappings":[{"valueAxis":"duration","rangeAxis":""}]},"honeycomb":{"shape":"square"}},"visualization":"table"},"38":{"type":"code","title":"Problem MTTR (Minutes)","input":"import { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nasync function getProblemsList() {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n   //from: 'now-7d', problemSelector: 'managementZones(\"EasyTrade\")'\n    from: startTime,to: endTime, problemSelector: \"status(Closed), text(\\\"outage\\\")\"\n    //from: 'now-7d', problemSelector: \"status(Open)\"\n  });\n  const result = await response;\n // console.log(result.problems);\n  return result.problems;\n}\n\nfunction expandArray(array) {\n  if (array.length == 1) {\n    return array[0].name;\n  } else if (array.length > 1) {\n    var retVal = \"\"\n    for (let i=0;i<array.length;i++) {\n      if (i!=0) {\n        retVal = retVal + \", \" + array[i].name;\n      } else {\n        retVal = array[i].name;\n      }\n    }\n    return retVal;\n  }\n  return \"\"; \n}\n\nexport default async function () {\n  const response = await getProblemsList();\n  //console.log(response);\n  const problems=response;\n  const types = [{\n      mappings: {\n        startTime: {type: 'timestamp'},\n        status: {type: 'string'},\n        displayId: {type: 'string'},\n        title: {type: 'string'},\n        impactLevel: {type: 'string'},\n        severityLevel: {type: 'string'},\n        affectedEntities: {type: 'string'},\n        impactedEntities: {type: 'string'},\n        rootCauseEntity: {type: 'string'},\n        duration: {type: 'double'},\n        \"event.id\": {type: 'string'},\n        endTime: {type: 'timestamp'}\n        },\n        indexRange: [\n        0,\n        problems.length\n      ]\n  }]\n  //console.log(types);\n  // Create a new empty data frame for the result\n  const dataFrame = {\n    records: [],\n    types: types\n  }\n  var mttr = 0;\n  for(let i=0; i<problems.length; i++) {\n      const problem = problems[i];\n      var duration = \"\";\n      if (problem.endTime == null || problem.endTime == \"\" || problem.endTime < 0) {\n        duration = Math.round(((Date.now() - problem.startTime)/1000)/60);\n      } else {\n        duration = Math.round(((problem.endTime-problem.startTime)/1000)/60);\n      }\n      mttr = mttr + duration;\n      var pstatus = \"\";\n      if (problem.status == 'OPEN') {\n        pstatus = \"ðŸ”´ OPEN\";\n      } else {\n        pstatus = 'ðŸŸ¢ CLOSED';\n      }\n      var affectedEntities = expandArray(problem.affectedEntities);\n      var impactedEntities = expandArray(problem.impactedEntities);\n      var rootCause = \"\";\n      if (problem.rootCauseEntity == null) {\n        rootCause = \"\"\n      } else {\n        rootCause = problem.rootCauseEntity[\"name\"];\n      }\n       const record = {\n              startTime: problem.startTime,\n              status: pstatus,\n              displayId: problem.displayId,\n              title: problem.title,\n              impactLevel: problem.impactLevel,\n              severityLevel: problem.severityLevel,\n              affectedEntities: affectedEntities,\n              impactedEntities: impactedEntities,\n              rootCauseEntity: rootCause,\n              duration: duration,\n              \"event.id\": problem.problemId,\n              endTime: problem.endTime\n            }\n        dataFrame.records.push(record);\n    }\n  //console.log(dataFrame);\n//  return dataFrame;\n  return mttr/problems.length;\n}","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"MTTR","autoscale":true,"recordField":"element"},"table":{"enableLineWrap":true,"hiddenColumns":[["severityLevel"],["affectedEntities"],["impactedEntities"],["rootCauseEntity"],["event.id"]],"lineWrapIds":[["affectedEntities"]]},"tableSettings":{"displayMode":"edit","lineWrapIds":[],"hiddenColumns":[["dataPond"],["rollupType"],["tenant"],["recordType"],["impactLevel"],["endTime"]],"firstVisibleRowIndex":0},"histogram":{"dataMappings":[{"valueAxis":"element","rangeAxis":""}]},"honeycomb":{"shape":"square"}},"visualization":"singleValue"},"43":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"44":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"45":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"46":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"47":{"type":"code","title":"Open Problems","input":"import { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nasync function getProblemsList() {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n   //from: 'now-7d', problemSelector: 'managementZones(\"EasyTrade\")'\n    from: startTime,to: endTime, problemSelector: \"status(Open), text(\\\"outage\\\")\"\n    //from: 'now-7d', problemSelector: \"status(Open)\"\n  });\n  const result = await response;\n // console.log(result.problems);\n  return result.problems;\n}\n\nfunction expandArray(array) {\n  if (array.length == 1) {\n    return array[0].name;\n  } else if (array.length > 1) {\n    var retVal = \"\"\n    for (let i=0;i<array.length;i++) {\n      if (i!=0) {\n        retVal = retVal + \", \" + array[i].name;\n      } else {\n        retVal = array[i].name;\n      }\n    }\n    return retVal;\n  }\n  return \"\"; \n}\n\nexport default async function () {\n  const response = await getProblemsList();\n  //console.log(response);\n  const problems=response;\n  const types = [{\n      mappings: {\n        startTime: {type: 'timestamp'},\n        status: {type: 'string'},\n        displayId: {type: 'string'},\n        title: {type: 'string'},\n        impactLevel: {type: 'string'},\n        severityLevel: {type: 'string'},\n        affectedEntities: {type: 'string'},\n        duration: {type: 'double'},\n        impactedEntities: {type: 'string'},\n        rootCauseEntity: {type: 'string'},\n        \"event.id\": {type: 'string'},\n        endTime: {type: 'timestamp'}\n        },\n        indexRange: [\n        0,\n        problems.length\n      ]\n  }]\n  //console.log(types);\n  // Create a new empty data frame for the result\n  const dataFrame = {\n    records: [],\n    types: types\n  }\n  \n  for(let i=0; i<problems.length; i++) {\n      const problem = problems[i];\n      var duration = \"\";\n      if (problem.endTime == null || problem.endTime == \"\" || problem.endTime < 0) {\n        duration = Math.round(((Date.now() - problem.startTime)/1000)/60);\n      } else {\n        duration = Math.round(((problem.endTime-problem.startTime)/1000)/60);\n      }\n      var pstatus = \"\";\n      if (problem.status == 'OPEN') {\n        pstatus = \"ðŸ”´ OPEN\";\n      } else {\n        pstatus = 'ðŸŸ¢ CLOSED';\n      }\n      var affectedEntities = expandArray(problem.affectedEntities);\n      var impactedEntities = expandArray(problem.impactedEntities);\n      var rootCause = \"\";\n      if (problem.rootCauseEntity == null) {\n        rootCause = \"\"\n      } else {\n        rootCause = problem.rootCauseEntity[\"name\"];\n      }\n       const record = {\n              startTime: problem.startTime,\n              status: pstatus,\n              displayId: problem.displayId,\n              title: problem.title,\n              impactLevel: problem.impactLevel,\n              severityLevel: problem.severityLevel,\n              affectedEntities: affectedEntities,\n              impactedEntities: impactedEntities,\n              rootCauseEntity: rootCause,\n              duration: duration,\n              \"event.id\": problem.problemId,\n              endTime: problem.endTime\n            }\n        dataFrame.records.push(record);\n    }\n  //console.log(dataFrame);\n  return dataFrame;\n}","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","categoricalBarChartSettings":{"categoryAxis":"status","categoryAxisLabel":"status","valueAxis":"duration","valueAxisLabel":"duration"},"fieldMapping":{"timestamp":"startTime","leftAxisValues":["duration"],"leftAxisDimensions":["status"]}},"singleValue":{"showLabel":true,"label":"","autoscale":true,"recordField":"startTime"},"table":{"enableLineWrap":true,"hiddenColumns":[["status"],["impactLevel"],["severityLevel"],["affectedEntities"],["endTime"],["rootCauseEntity"]],"lineWrapIds":[["affectedEntities"]]},"tableSettings":{"displayMode":"edit","lineWrapIds":[],"hiddenColumns":[["dataPond"],["rollupType"],["tenant"],["recordType"],["impactLevel"],["endTime"]],"firstVisibleRowIndex":0},"histogram":{"dataMappings":[{"valueAxis":"duration","rangeAxis":""}]},"honeycomb":{"shape":"square"}},"visualization":"table"},"51":{"type":"data","title":"Problems by Event","query":"fetch events, from:$dt_timeframe_from, to:$dt_timeframe_to \n| filter matchesValue(event.kind, \"DAVIS_PROBLEM\")\n| filter like(event.name,\"%outage\")\n| summarize count = countDistinct(display_id), by:{event.name}\n| sort count, direction:\"descending\"","visualization":"pieChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"legend":{"position":"right","hidden":false},"categoricalBarChartSettings":{"categoryAxis":"event.name","categoryAxisLabel":"event.name","valueAxis":"count","valueAxisLabel":"count"}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center","recordField":"event.name"},"table":{"rowDensity":"condensed","enableLineWrap":true,"enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}},"histogram":{"dataMappings":[{"valueAxis":"count","rangeAxis":""}]},"honeycomb":{"shape":"square"}}},"53":{"type":"data","title":"Closed Problem Count","query":"fetch events, from:$dt_timeframe_from, to:$dt_timeframe_to\n| filter event.kind == \"DAVIS_PROBLEM\" and matchesValue(event.status,\"CLOSED\")\n| filter like(event.name,\"%outage\")\n| summarize {activeEvents = countDistinct(event.id)}","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center","recordField":"activeEvents"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{},"lineWrapIds":[["affected_entity_ids"]],"enableLineWrap":true},"histogram":{"dataMappings":[{"valueAxis":"activeEvents","rangeAxis":""}]},"honeycomb":{"shape":"square"}},"visualization":"singleValue"},"54":{"type":"data","title":"Problem Count","query":"fetch events, from:$dt_timeframe_from, to:$dt_timeframe_to\n| filter event.kind == \"DAVIS_PROBLEM\"\n| filter like(event.name,\"%outage\")\n| summarize {activeEvents = countDistinct(event.id), by: {`10m interval` = bin(timestamp, 10m)}}","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"seriesOverrides":[{"seriesId":["activeEvents"],"override":{"color":{"Default":"var(--dt-colors-charts-security-risk-level-critical-default, #8a0012)"}}}],"legend":{"hidden":true},"fieldMapping":{"timestamp":"10m interval","leftAxisValues":["activeEvents"],"leftAxisDimensions":[],"fields":[],"values":[]}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center","recordField":"10m interval"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{},"lineWrapIds":[["affected_entity_ids"]],"enableLineWrap":true},"histogram":{"dataMappings":[{"valueAxis":"activeEvents","rangeAxis":""}]},"honeycomb":{"shape":"square"}},"visualization":"areaChart","davis":{"enabled":false,"componentState":{"selectedAnalyzerName":"dt.statistics.ui.ForecastAnalyzer","inputData":{"dt.statistics.ui.ForecastAnalyzer":{"generalParameters":{"timeframe":{"startTime":"2023-12-28T17:39:04.771Z","endTime":"2024-01-04T17:39:04.771Z"},"resolveDimensionalQueryData":true,"logVerbosity":"INFO"},"forecastHorizon":100,"query":{"expression":"fetch events\n| filter event.kind == \"DAVIS_PROBLEM\"\n| filter like(event.name,\"%outage\")\n| summarize {activeEvents = countDistinct(event.id), by: {`10m interval` = bin(timestamp, 10m)}}"}}}}}},"55":{"type":"data","title":"Closed Problems by Event","query":"fetch events, from:$dt_timeframe_from, to:$dt_timeframe_to \n| filter matchesValue(event.kind, \"DAVIS_PROBLEM\") and matchesValue(event.status,\"CLOSED\")\n| filter like(event.name,\"%outage\")\n| summarize count = countDistinct(display_id), by:{event.name}\n| sort count, direction:\"descending\"","visualization":"pieChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute","hideLabels":true},"legend":{"position":"right","hidden":false},"categoricalBarChartSettings":{"categoryAxis":"event.name","categoryAxisLabel":"event.name","valueAxis":"count","valueAxisLabel":"count"}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center","recordField":"event.name"},"table":{"rowDensity":"condensed","enableLineWrap":true,"enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}},"histogram":{"dataMappings":[{"valueAxis":"count","rangeAxis":""}]},"honeycomb":{"shape":"square"}},"davis":{"enabled":false,"componentState":{"selectedAnalyzerName":"dt.statistics.ui.ForecastAnalyzer","inputData":{"dt.statistics.ui.ForecastAnalyzer":{"generalParameters":{"timeframe":{"startTime":"now-2h","endTime":"now"},"resolveDimensionalQueryData":true,"logVerbosity":"INFO"},"forecastHorizon":100,"query":{"expression":"fetch events, from:$dt_timeframe_from, to:$dt_timeframe_to \n| filter matchesValue(event.kind, \"DAVIS_PROBLEM\") and matchesValue(event.status,\"CLOSED\")\n| filter like(event.name,\"%outage\")\n| summarize count = countDistinct(display_id), by:{event.name}\n| sort count, direction:\"descending\""}}}}}},"56":{"type":"data","title":"Top Problems by Event","query":"fetch events, from:$dt_timeframe_from, to:$dt_timeframe_to\n| filter event.kind == \"DAVIS_PROBLEM\"\n| filter like(event.name,\"%outage\")\n| summarize by:{event.name}, count = countDistinct(display_id)\n| sort count, direction:\"descending\"\n| limit 10","visualization":"categoricalBarChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoricalBarChartSettings":{"categoryAxis":"event.name","categoryAxisLabel":"Event","valueAxis":"count","valueAxisLabel":"Count","layout":"horizontal","scale":"absolute"},"colorPalette":"vulnerability-risk-level","legend":{"hidden":true}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center","recordField":"event.name"},"table":{"rowDensity":"condensed","enableLineWrap":true,"enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}},"histogram":{"dataMappings":[{"valueAxis":"count","rangeAxis":""}]},"honeycomb":{"shape":"square"}}},"57":{"type":"code","title":"Open Problem Count","input":"import { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nasync function getProblemsList() {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n   //from: 'now-7d', problemSelector: 'managementZones(\"EasyTrade\")'\n    from: startTime,to: endTime, problemSelector: \"status(Open), text(\\\"outage\\\")\"\n    //from: 'now-7d', problemSelector: \"status(Open)\"\n  });\n  const result = await response;\n  //console.log(result.problems);\n  return result.problems;\n}\n\nfunction expandArray(array) {\n  if (array.length == 1) {\n    return array[0].name;\n  } else if (array.length > 1) {\n    var retVal = \"\"\n    for (let i=0;i<array.length;i++) {\n      if (i!=0) {\n        retVal = retVal + \", \" + array[i].name;\n      } else {\n        retVal = array[i].name;\n      }\n    }\n    return retVal;\n  }\n  return \"\"; \n}\n\nexport default async function () {\n  const response = await getProblemsList();\n  //console.log(response);\n  const problems=response;\n  return problems.length;\n  \n}","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","categoricalBarChartSettings":{"categoryAxis":"status","categoryAxisLabel":"status","valueAxis":"duration","valueAxisLabel":"duration"},"fieldMapping":{"timestamp":"startTime","leftAxisValues":["duration"],"leftAxisDimensions":["status"]}},"singleValue":{"showLabel":false,"label":"","autoscale":true,"recordField":"element"},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["affectedEntities"]]},"tableSettings":{"displayMode":"edit","lineWrapIds":[],"hiddenColumns":[["dataPond"],["rollupType"],["tenant"],["recordType"],["impactLevel"],["endTime"]],"firstVisibleRowIndex":0},"histogram":{"dataMappings":[{"valueAxis":"element","rangeAxis":""}]},"honeycomb":{"shape":"square"}},"visualization":"singleValue"},"58":{"type":"markdown","title":"","content":"#\n# ðŸ”Ž Outage Overview"},"59":{"type":"code","title":"Outage Cost","input":"import { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nasync function getProblemsList() {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n    from: startTime,to: endTime, problemSelector: \"text(\\\"outage\\\")\"\n  });\n  const result = await response;\n  return result.problems;\n  }\n\n  export default async function () {\n  const response = await getProblemsList();\n  const problems=response;\n  var mttr = 0;\n  for(let i=0; i<problems.length; i++) {\n      const problem = problems[i];\n      var duration = \"\";\n      if (problem.endTime == null || problem.endTime == \"\" || problem.endTime < 0) {\n        duration = Math.round(((Date.now() - problem.startTime)/1000)/60);\n      } else {\n        duration = Math.round(((problem.endTime-problem.startTime)/1000)/60);\n      }\n      mttr = mttr + duration;\n    }\nconsole.log(mttr*$OutageCost);\n    return \"$\"+Intl.NumberFormat().format(mttr*$OutageCost);\n}","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"MTTR","autoscale":true,"recordField":"element"},"table":{"enableLineWrap":true,"hiddenColumns":[["severityLevel"],["affectedEntities"],["impactedEntities"],["rootCauseEntity"],["event.id"]],"lineWrapIds":[["affectedEntities"]]},"tableSettings":{"displayMode":"edit","lineWrapIds":[],"hiddenColumns":[["dataPond"],["rollupType"],["tenant"],["recordType"],["impactLevel"],["endTime"]],"firstVisibleRowIndex":0},"unitsOverrides":[],"histogram":{"dataMappings":[]},"honeycomb":{"shape":"square"}},"visualization":"singleValue"}},"layouts":{"33":{"x":12,"y":14,"w":11,"h":4},"38":{"x":16,"y":1,"w":4,"h":2},"43":{"x":0,"y":0,"w":24,"h":1},"44":{"x":0,"y":3,"w":24,"h":1},"45":{"x":0,"y":18,"w":24,"h":1},"46":{"x":0,"y":13,"w":24,"h":1},"47":{"x":0,"y":14,"w":11,"h":4},"51":{"x":0,"y":4,"w":8,"h":5},"53":{"x":12,"y":1,"w":4,"h":2},"54":{"x":0,"y":9,"w":23,"h":4},"55":{"x":15,"y":4,"w":8,"h":5},"56":{"x":8,"y":4,"w":7,"h":5},"57":{"x":8,"y":1,"w":4,"h":2},"58":{"x":0,"y":1,"w":8,"h":2},"59":{"x":20,"y":1,"w":4,"h":2}},"refreshRate":0}