{"version":13,"variables":[{"key":"service","type":"query","input":"fetch dt.entity.service\n| fields entity.name","multiple":true}],"tiles":{"1":{"type":"code","title":"Average Response Time (s)","input":"/*\n * This function will run in the DYNATRACE JavaScript runtime.\n * For information visit https://dt-url.net/functions-help\n */\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function fetchMetricResults() {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Peak Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Peak End Time\n  const startShiftTime = startTime-(25200000);       // Non Peak Start Time\n  const endShiftTime = endTime-(25200000);           // Non Peak End Time\n  const serviceSelection = $service;\n  const metricKey = \"builtin:service.errors.total.rate\";\n\n  const config = {\n    metricSelector: buildQuery(serviceSelection, metricKey),\n    resolution: \"Inf\",\n    from: startTime,\n    to: endTime,\n    acceptType: \"application/json; charset=utf-8\"\n  };\n  const config2 = {\n    metricSelector: buildQuery(serviceSelection, metricKey),\n    resolution: \"Inf\",\n    from: startShiftTime,\n    to: endShiftTime,\n    acceptType: \"application/json; charset=utf-8\"\n  };\n\n  if (config.metricSelector.length > 3500) {\n    return \"Please select fewer services\";\n  }\n\n  const metricQuery = await metricsClient.query(config);\n  const metricQuery2 = await metricsClient.query(config2);\n\n  let lib = {};\n  \n  const processedResults: MetricResult[] = metricQuery.result[0].data.map(result => {\n    lib[result.dimensionMap[\"dt.entity.service\"]] = {\n      \"name\":result.dimensionMap[\"dt.entity.service.name\"],\n      \"peak\": result.values\n    };\n    return {\n      \"Service Name\": result.dimensionMap[\"dt.entity.service.name\"],\n      \"Service ID\": result.dimensionMap[\"dt.entity.service\"],\n      \"Peak Error Rate\": result.values\n    };\n  });\n  const processedResults2: MetricResult[] = metricQuery2.result[0].data.map(result => {\n    const peak = lib[result.dimensionMap[\"dt.entity.service\"]][\"peak\"];\n    const nPeak = result.values;\n    return {\n      \"Service Name\": result.dimensionMap[\"dt.entity.service.name\"],\n      \"Service ID\": result.dimensionMap[\"dt.entity.service\"],\n      \"Non Peak Error Rate\": nPeak,      \n      \"RAW Diff\": (parseFloat(peak) - parseFloat(nPeak)),\n      \"% Diff\": ((parseFloat(peak) - parseFloat(nPeak)) / ( (parseFloat(peak) + parseFloat(nPeak)) / 2)) * (100)\n    };\n  });\n\n\nconst arr = []\nfor (let i=0;i<processedResults.length;i++) {\n  arr.push({...processedResults[i], ...processedResults2[i]})\n}\nreturn arr;\n//  return processedResults;\n  \n}\n\nfunction buildQuery(inputs: string[], metricKey: string): string {\n  const filters = inputs.map(\n    input => `in(\"dt.entity.service\", entitySelector(\"type(service), entityName.equals(~\"${input}~\")\"))`\n  );\n  const filterString = filters.join(\",\");\n\n  return `${metricKey}:filter(or(${filterString})):splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n}","visualization":"table","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","categoricalBarChartSettings":{"categoryAxis":"Service Name","categoryAxisLabel":"Service Name","valueAxis":"Avg Response Time (Ms)","valueAxisLabel":"Avg Response Time (Ms)"},"fieldMapping":{"timestamp":null,"leftAxisValues":["Peak Error Rate","Non Peak Error Rate"],"leftAxisDimensions":["Service Name","Service ID","RAW Diff","% Diff"],"fields":[],"values":[]}},"singleValue":{"showLabel":true,"label":"","autoscale":true,"recordField":"Service Name"},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["service_name"]],"sortBy":{"columnId":"[\"% Diff\"]","direction":"descending"}},"histogram":{"dataMappings":[{"valueAxis":"RAW Diff","rangeAxis":""},{"valueAxis":"% Diff","rangeAxis":""}]},"honeycomb":{"shape":"square"}}}},"layouts":{"1":{"x":0,"y":0,"w":24,"h":13}}}